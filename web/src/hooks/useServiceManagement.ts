import { useState, useCallback } from "react";
import { Service } from "@/types";
import { useProfile } from "@/contexts/ProfileContext";
import { useToast, toast } from "@/components/ui/toast";
import { ServiceOperations } from "@/services/serviceOperations";
import { useModalManager } from "./useModalManager";

export function useServiceManagement(onServiceUpdated: () => void) {
  const { activeProfile, removeServiceFromProfile, refreshProfiles } =
    useProfile();
  const { addToast } = useToast();

  // Modal management
  const modalManager = useModalManager([
    "serviceConfig",
    "serviceFiles",
    "serviceEnv",
    "serviceAction",
    "libraryInstall",
  ]);

  // Service creation state
  const [isCreatingService, setIsCreatingService] = useState(false);
  const [isSavingService, setIsSavingService] = useState(false);

  const openCreateService = useCallback(() => {
    const newService: Service = {
      id: "", // UUID will be generated by backend
      name: "",
      dir: "",
      extraEnv: "",
      javaOpts: "",
      status: "stopped",
      healthStatus: "unknown",
      healthUrl: "",
      port: 8080,
      pid: 0,
      order: 0, // Will be set when we have all services
      lastStarted: new Date().toISOString(),
      description: "",
      isEnabled: true,
      buildSystem: "auto",
      envVars: {},
      logs: [],
      uptime: "",
      cpuPercent: 0,
      memoryUsage: 0,
      memoryPercent: 0,
      diskUsage: 0,
      networkRx: 0,
      networkTx: 0,
      metrics: {
        responseTimes: [],
        errorRate: 0,
        requestCount: 0,
        lastChecked: new Date().toISOString(),
      },
      dependencies: null,
      dependentOn: null,
      startupDelay: 0,
    };

    setIsCreatingService(true);
    modalManager.openModal("serviceConfig", newService);
  }, [modalManager]);

  const openEditService = useCallback(
    (service: Service) => {
      setIsCreatingService(false);
      modalManager.openModal("serviceConfig", service);
    },
    [modalManager],
  );

  const openViewFiles = useCallback(
    (service: Service) => {
      modalManager.openModal("serviceFiles", service);
    },
    [modalManager],
  );

  const openEditEnv = useCallback(
    (service: Service) => {
      modalManager.openModal("serviceEnv", service);
    },
    [modalManager],
  );

  const openLibraryInstall = useCallback(
    (service: Service) => {
      modalManager.openModal("libraryInstall", service);
    },
    [modalManager],
  );

  const deleteService = useCallback(
    (serviceName: string, services: Service[]) => {
      const service = services.find((s) => s.name === serviceName);
      if (!service) return;

      modalManager.openModal("serviceAction", service);
    },
    [modalManager],
  );

  const handleRemoveFromProfile = useCallback(
    async (serviceName: string) => {
      if (!activeProfile) return;

      try {
        await removeServiceFromProfile(activeProfile.id, serviceName);
        addToast(
          toast.success(
            "Service removed from profile",
            `${serviceName} has been removed from ${activeProfile.name}`,
          ),
        );
        // Refresh both services and profile data
        await Promise.all([onServiceUpdated(), refreshProfiles()]);
      } catch (error) {
        console.error("Failed to remove service from profile:", error);
        addToast(
          toast.error(
            "Failed to remove service from profile",
            error instanceof Error
              ? error.message
              : "An unexpected error occurred",
          ),
        );
      }
    },
    [
      activeProfile,
      removeServiceFromProfile,
      addToast,
      onServiceUpdated,
      refreshProfiles,
    ],
  );

  const handleDeleteGlobally = useCallback(
    async (service: Service) => {
      const result = await ServiceOperations.deleteService(service.id);

      if (result.success) {
        addToast(toast.success("Service deleted", result.message!));
        // Refresh both services and profile data
        await Promise.all([onServiceUpdated(), refreshProfiles()]);
      } else {
        addToast(toast.error("Failed to delete service", result.error!));
      }
    },
    [addToast, onServiceUpdated, refreshProfiles],
  );

  const handleSaveService = useCallback(
    async (service: Service, profileId?: string) => {
      try {
        setIsSavingService(true);
        const isCreate = isCreatingService;

        // For updates, use the service UUID. For creation, POST to /api/services
        const url = isCreate ? "/api/services" : `/api/services/${service.id}`;
        const method = isCreate ? "POST" : "PUT";

        console.log("Saving service:", {
          method,
          url,
          service,
          isCreate,
        });

        const payload = {
          id: service.id || "",
          name: service.name || "",
          dir: service.dir || "",
          extraEnv: service.extraEnv || "",
          javaOpts: service.javaOpts || "",
          healthUrl:
            service.healthUrl ||
            `http://localhost:${service.port || 8080}/actuator/health`,
          port: service.port || 8080,
          order: service.order || 0,
          description: service.description || "",
          isEnabled: service.isEnabled || true,
          buildSystem: service.buildSystem || "auto",
          envVars: service.envVars || {},
          startupDelay: service.startupDelay || 0,
        };

        const response = await fetch(url, {
          method: method,
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!response.ok) {
          throw new Error(
            `Failed to ${isCreate ? "create" : "save"} service: ${response.status} ${response.statusText}`,
          );
        }

        // Get the response data (contains the service with backend-generated UUID for new services)
        const responseData = await response.json();
        const savedService = responseData.service || responseData;

        // If creating a new service and a profile was selected, add it to the profile
        if (isCreate && profileId && savedService.id) {
          try {
            const addToProfileResponse = await fetch(
              `/api/profiles/${profileId}/services`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ serviceId: savedService.id }),
              },
            );
            if (!addToProfileResponse.ok) {
              console.warn(
                "Failed to add service to profile, but service was created successfully",
              );
            }
          } catch (error) {
            console.warn("Failed to add service to profile:", error);
          }
        }

        addToast(
          toast.success(
            isCreate ? "Service created" : "Service saved",
            `${service.name} has been ${isCreate ? "created" : "updated"} successfully${profileId && isCreate ? " and added to profile" : ""}`,
          ),
        );
        // Refresh both services and profile data
        await Promise.all([onServiceUpdated(), refreshProfiles()]);
        modalManager.closeModal("serviceConfig");
        setIsCreatingService(false);
      } catch (error) {
        console.error("Failed to save service:", error);
        addToast(
          toast.error(
            "Failed to save service",
            error instanceof Error
              ? error.message
              : "An unexpected error occurred",
          ),
        );
      } finally {
        setIsSavingService(false);
      }
    },
    [
      isCreatingService,
      modalManager,
      addToast,
      onServiceUpdated,
      refreshProfiles,
    ],
  );

  return {
    // Modal manager
    modalManager,

    // Modal states
    isCreatingService,
    isSavingService,

    // Modal helpers
    isServiceConfigOpen: modalManager.isModalOpen("serviceConfig"),
    isServiceFilesOpen: modalManager.isModalOpen("serviceFiles"),
    isServiceEnvOpen: modalManager.isModalOpen("serviceEnv"),
    isServiceActionOpen: modalManager.isModalOpen("serviceAction"),
    isLibraryInstallOpen: modalManager.isModalOpen("libraryInstall"),

    // Modal data
    serviceConfigData: modalManager.getModalData<Service>("serviceConfig"),
    serviceFilesData: modalManager.getModalData<Service>("serviceFiles"),
    serviceEnvData: modalManager.getModalData<Service>("serviceEnv"),
    serviceActionData: modalManager.getModalData<Service>("serviceAction"),
    libraryInstallData: modalManager.getModalData<Service>("libraryInstall"),

    // Actions
    openCreateService,
    openEditService,
    openViewFiles,
    openEditEnv,
    openLibraryInstall,
    deleteService,
    handleRemoveFromProfile,
    handleDeleteGlobally,
    handleSaveService,

    // Close handlers - now using modal manager
    closeServiceConfig: () => {
      modalManager.closeModal("serviceConfig");
      setIsCreatingService(false);
    },
    closeServiceFiles: () => modalManager.closeModal("serviceFiles"),
    closeServiceEnv: () => modalManager.closeModal("serviceEnv"),
    closeServiceActionModal: () => modalManager.closeModal("serviceAction"),
    closeLibraryInstall: () => modalManager.closeModal("libraryInstall"),
  };
}
